#!/usr/bin/env tsx

/**
 * Generate runtime TS path aliases for Node.js production execution.
 *
 * Source of truth: tsconfig.base.json -> compilerOptions.paths
 *
 * This script generates a deterministic module that registers tsconfig-paths
 * against the compiled output in dist/, without reading tsconfig at runtime.
 *
 * Usage:
 *   tsx tools/scripts/generate-runtime-paths.ts
 *
 * Output:
 *   libs/infra/runtime-paths/src/lib/register-paths.generated.ts
 */

import { readFileSync, writeFileSync } from 'node:fs';
import { dirname, join, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';

function getRepoRoot(): string {
  if (process.env['NX_WORKSPACE_ROOT']) {
    return process.env['NX_WORKSPACE_ROOT'];
  }

  // tools/scripts/ -> repo root
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = dirname(__filename);
  return resolve(__dirname, '../..');
}

const REPO_ROOT = getRepoRoot();

const TSCONFIG_BASE_PATH = join(REPO_ROOT, 'tsconfig.base.json');
const OUTPUT_PATH = join(REPO_ROOT, 'libs/infra/runtime-paths/src/lib/register-paths.generated.ts');

interface TsConfig {
  compilerOptions?: {
    baseUrl?: string;
    paths?: Record<string, string[]>;
  };
}

/**
 * Normalize path to POSIX format (for Windows compatibility).
 */
function normalizePath(path: string): string {
  return path.replace(/\\/g, '/');
}

/**
 * Validate that path values are from expected locations (libs/ or apps/).
 */
function validatePathValue(pathValue: string): void {
  const normalized = normalizePath(pathValue);
  
  // Wildcards and folder paths without extensions are OK
  if (normalized.includes('*') || !normalized.includes('.')) {
    if (normalized.startsWith('libs/') || normalized.startsWith('apps/')) {
      return;
    }
  }
  
  // File paths with extensions
  if (normalized.match(/\.(ts|tsx|js|json)$/)) {
    if (normalized.startsWith('libs/') || normalized.startsWith('apps/')) {
      return;
    }
  }
  
  throw new Error(
    `Invalid path value: "${pathValue}". ` +
    `Expected paths to start with "libs/" or "apps/". ` +
    `Check tsconfig.base.json compilerOptions.paths for suspicious entries.`
  );
}

/**
 * Converts TypeScript path alias targets into runtime targets.
 *
 * Rules:
 * - Normalize to POSIX format (replace backslashes for Windows)
 * - Convert .ts/.tsx extensions to .js
 * - Keep folder paths (no extension) as-is
 * - Keep wildcard paths (/*) as-is
 * - Validate that paths are from libs/ or apps/
 *
 * Examples:
 * - "libs/api/users/src/index.ts" -> "libs/api/users/src/index.js"
 * - "libs/web/ui/src" -> "libs/web/ui/src"
 * - "libs/shared/tailwind/src/*" -> "libs/shared/tailwind/src/*"
 */
function convertPathsToRuntime(tsPaths: Record<string, string[]>): Record<string, string[]> {
  const runtimePaths: Record<string, string[]> = {};

  // Sort keys for deterministic output
  const sortedKeys = Object.keys(tsPaths).sort();

  for (const alias of sortedKeys) {
    const paths = tsPaths[alias];
    
    runtimePaths[alias] = paths.map((tsPath) => {
      // Validate path
      validatePathValue(tsPath);
      
      // Normalize to POSIX
      const normalized = normalizePath(tsPath);
      
      // Convert .ts/.tsx to .js
      return normalized.replace(/\.tsx?$/, '.js');
    }).sort(); // Sort values for deterministic output
  }

  return runtimePaths;
}

/**
 * Generates the register-paths.generated.ts file content.
 */
function generateFileContent(runtimePaths: Record<string, string[]>): string {
  const runtimePathsJson = JSON.stringify(runtimePaths, null, 2);

  return `/**
 * AUTO-GENERATED. DO NOT EDIT.
 *
 * This file is automatically generated by tools/scripts/generate-runtime-paths.ts
 * Source: tsconfig.base.json compilerOptions.paths
 *
 * To regenerate:
 *   pnpm nx run infra-runtime-paths:gen:runtime-paths
 *
 * Do not modify this file manually. Your changes will be overwritten.
 */

import { existsSync } from 'node:fs';
import { resolve } from 'node:path';
import { register } from 'tsconfig-paths';

/**
 * Runtime path mappings derived from tsconfig.base.json.
 * TypeScript paths (.ts/.tsx) have been converted to JavaScript (.js).
 */
const runtimePaths: Record<string, string[]> = ${runtimePathsJson};

/**
 * Robustly compute the workspace dist root directory.
 *
 * Strategy (in order):
 * 1. Use NX_WORKSPACE_ROOT env var if available (Nx standard)
 * 2. Walk up from __dirname to find a directory containing dist/apps or dist/libs
 * 3. Walk up from process.cwd() to find a directory containing dist/
 * 4. Fail with descriptive error
 */
function computeDistRoot(): string {
  // Strategy 1: Prefer Nx-provided workspace root
  const workspaceRoot = process.env['NX_WORKSPACE_ROOT'];
  if (workspaceRoot) {
    return resolve(workspaceRoot, 'dist');
  }

  // Strategy 2: Walk up from __dirname to find workspace with dist/apps or dist/libs
  let current = __dirname;
  for (let i = 0; i < 10; i++) {
    const distPath = resolve(current, 'dist');
    const distApps = resolve(distPath, 'apps');
    const distLibs = resolve(distPath, 'libs');
    
    if (existsSync(distApps) || existsSync(distLibs)) {
      return distPath;
    }

    const parent = resolve(current, '..');
    if (parent === current) break; // Reached filesystem root
    current = parent;
  }

  // Strategy 3: Walk up from cwd to find dist folder
  current = process.cwd();
  for (let i = 0; i < 10; i++) {
    const candidate = resolve(current, 'dist');
    if (existsSync(candidate)) {
      return candidate;
    }

    const parent = resolve(current, '..');
    if (parent === current) break;
    current = parent;
  }

  // Strategy 4: Fail with helpful message
  throw new Error(
    [
      'Unable to locate workspace dist directory.',
      'Tried: NX_WORKSPACE_ROOT env var, walking up from __dirname, walking up from cwd.',
      'Ensure you are running from within the workspace, or set NX_WORKSPACE_ROOT environment variable.',
    ].join(' ')
  );
}

/**
 * Register TypeScript path aliases for runtime resolution.
 * This function is idempotent and safe to call multiple times.
 */
export function registerRuntimeTsPaths(): void {
  const g = globalThis as typeof globalThis & { __ks_ts_paths_registered__?: boolean };
  
  // Idempotent guard - prevent double registration
  if (g.__ks_ts_paths_registered__) {
    return;
  }

  const distRoot = computeDistRoot();
  register({ baseUrl: distRoot, paths: runtimePaths });

  g.__ks_ts_paths_registered__ = true;
}

// Auto-register on module load (side effect)
registerRuntimeTsPaths();
`;
}

/**
 * Main execution.
 */
function main(): void {
  // Read and parse tsconfig.base.json
  const tsconfigContent = readFileSync(TSCONFIG_BASE_PATH, 'utf-8');
  const tsconfig: TsConfig = JSON.parse(tsconfigContent);

  if (!tsconfig.compilerOptions?.paths) {
    throw new Error('No paths found in tsconfig.base.json compilerOptions');
  }

  // Convert TS paths to runtime targets (extensionless, where applicable)
  const runtimePaths = convertPathsToRuntime(tsconfig.compilerOptions.paths);

  // Generate file content
  const fileContent = generateFileContent(runtimePaths);

  // Write output file
  writeFileSync(OUTPUT_PATH, fileContent, 'utf-8');
}

// Run if executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}
